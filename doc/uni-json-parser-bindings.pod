=head1 NAME

uni-json-parser-bindings - object creation and management functions for uni-json parser

=head1 SYNOPSIS

    #incluide <uni_json_p_binding.h>

    enum {
        UJ_NF_NEG = 1,              /* number is negative */
        UJ_NF_INT = 2               /* number is an integer */
    };

    struct uni_json_p_binding {
        /*  error handler */
        void (*on_error)(unsigned code, size_t pos, void *p);

        /*  objects */
        void *(*make_object)(void);
        void (*free_object)(void *obj);
        int (*add_2_object)(void *key, void *value, void *obj);

        /*  arrays */
        void *(*make_array)(void);
        void (*free_array)(void *ary);
        int (*add_2_array)(void *value, void *ary);

        /*  strings */
        void *(*make_string)(void);
        void (*free_string)(void *str);
        int (*add_2_string)(uint8_t *data, size_t len, void *str);

        /*  simple types */
        void *(*make_null)(void);
        void (*free_null)(void *null);

        void *(*make_bool)(int true_false);
        void (*free_bool)(void *boolean);

        void *(*make_number)(uint8_t *data, size_t len, unsigned flags);
        void (*free_number)(void *num);
    };

=head1 DESCRIPTION

Structure containing pointers to the functions which need to be provided to the uni-json parser
to use it in particular runtime environment.

=head2 Binding Functions

=head3 Error Handling

=over

=item * C<void on_error(unsigned code, size_t pos, void *p)>

Will be called in case of a parsing error before the C<uni_json_parse> function returns.
First argument will be the error code (see L<uni-json(3)> for a list), the second the offset
into the input string where the error was encountered. The third argument will be the
pointer value passed as final argument to C<uni_json_parse>.

By the time this handler is called, all memory implicitly allocated by earlier invocations of other handlers
will already have been freed. Functions causing a non-local control transfer, eg, the Perl API
function C<croak>, can thus safely be called from C<on_error>.

=back

=head3 Object Creation/ Management

=over

=item * C<void *make_object(void)>

Will be called when the parser wants to create an I<object>, something containing an unordered set
of key-value pairs.

Must return a pointer to an object.

=item * C<void free_object(void *obj)>

Will be called when the parser needs to free an object previously created via
C<make_object>. Should free all memory used for the object itself and whatever
is being used by the key-value pairs presently stored in it.

=item * C<int add_2_object(void *key, void *value, void *obj)>

Called when a key-value pair is to be added to an object. The B<key> will be a pointer
to a string created by C<make_string>, B<value> will be pointer to a value created
by invoking one of the other C<make_...> functions and B<obj> a pointer to the object
the key-value pair is supposed to be added to.

Supposed to return a true value when the addition succeeded or 0 in case of an error. If the store
was successful, both key and value are now owned by the object which is responsible for their
eventual disposal.

=back

=head3 Array Creation/ Management

=over

=item * C<void *make_array(void)>

Called by the parser when it wants to create an I<array>, an ordered set of values.

Must return a pointer to an array.

=item * C<void free_array(void *ary)>

Will be called when the parser needs to dispose of an array previously
created via C<make_array>. Should free all memory used for the array
itself and all values presently stored in it.

=item * <int add_2_array(void *value, void *ary)>

Called by the parser to add a value to the end of the array passed as B<ary>. B<value> will
be a pointer to another value created by invoking one of the C<make_...> functions.

Supposed to return a true value when the store was successful and 0 otherwise. If the
store was successful, the value will henceforth be owned by the array which is
responsible for its eventual disposal.

=back

=head3 String Creation/ Management

=over

=item * C<void *make_string(void)>

Called by the parser when it needs to create a I<string>. A string must be capable of
holding any valid UTF-8 string, possibly including bytes with value 0 or other
control characters.

Must return a pointer to a string.

=item * C<void free_string(void *str)>

Will be called by the parser when it wants to dispose of a string created
with C<make_string>. Should free all memory associated with the string.

=item * C<int add_2_string(uint8_t *data, size_t len, void *str>)

Add the sequence of bytes starting at B<data> of length B<len> to the string pointed to
by B<str>. The byte sequence will be a valid UTF-8 string.

Supposed to return a true value when the data was successfully stored and 0
otherwise.

=back

=head3 Creation of Simple Types

=over

=item * C<void *make_null(void)>

Called by the parser to create a I<null> value. Must return a pointer to one.

=item * C(void free_null(void *null)>

Called by the parser to free a null value.

=item * C<void *make_bool(int true_false)>

Called by the parser to create a I<boolean>. The value of the B<true_false> parameter will
evalute to true if the boolean value is supposed to be B<true> and will be 0 if it's
suppoed to be B<false>.

=item * C(void free_bool(void *bool)>

Called by the parser to free a boolean.

=item * C<void *make_number(uint8_t *data, size_t len, unsigned flags)>

Called by the parser to create a I<number>. The sequence of bytes starting at
B<data> of length B<len> will be a string conforming to the JSON number
syntax. The B<UJ_NF_NEG> bit will be set in B<flags> is the number is
supposed to be negative, the B<UJ_NF_INT> if it's an integral value, ie,
one with neither a fractional nor an exponent part.

=item * C(void free_number(void *num)>

Called by the parser to free a number.

=back

=head1 SEE ALSO

L<uni-json(3)>
